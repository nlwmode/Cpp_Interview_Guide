# C++常问基础知识50条

**各位看官，从头看到尾，包您在面试满意！**

1. [浅谈c++11新特性](https://www.jianshu.com/p/052865fd3478)
    1. **auto关键字**：
    auto关键字可以让编译器自动分析某个初始值来判断它所属的类型，利于快速的程序设计。**注意**使用auto关键字必须确定初始值；
    2. **decltype关键字**：
    脱型。功能是可以选择并返回操作数的数据类型，使编译器自动分析表达式的类型并得到该类型，并不会涉及到去计算表达式的值。
    ```cpp
        const int b = 10;
        decltype(b) x = 1;  // 获取 b 的类型，并使得 x 与 b 保持一样的类型
    ```
    3. **字面值 nullptr**:
    一般的定义空指针，将指针的初始值设为 0 或者 NULL (iostream库中NULL代表的就是0)。
    C++11引入字面值 nullptr来初始化空指针，其可以任意转换成其他的任意指针类型，保证了被复制的类型使相同的。
    4. **范围for语句**：
    有了这，再也不担心遍历那么麻烦了！在涉及复杂类型的容器遍历时，可以结合auto关键字一块使用。
    ```cpp
      vector<int> nums(10);
      for(int i = 0 ; i < 10 ; ++i)
         cout << n;
      for(int n : nums)
         cout << n;
    ```
    5. **lambda表达式**:
    貌似我们在sort函数里最常用。lambda可以说是一个可调用的代码单元，也可以是一个可调用的对象，还可以理解为一个没有命名的内联函数。拥有返回类型，形参列表，函数体等。
    [capture list] (parameter list) -> return type { function body}
    ```cpp
    vector<int> nums(10);
    sort(nums.begin() , nums.end() , [](const int& a , const int& b)->bool{
       return a > b;       // 升序排序
    });
    ```
    6. **初始化列表**
    初始化列表的顺序需要和变量声明的顺序一致，否则可能会出现还没被初始化的变量给其他变量赋值的情况。
    初始化列表还可以执行一些函数和操作。
    ```cpp
      class A{
         public:
            int a; int b ; int c;
            A(int x , int y , int z): a(x) , b(y) , c(z) , begin() {}  // 没问题
            A(): c(a) , a(0) , b(a) , begin(){}  // 出错，a还没有被初始化，不能去初始化c，b没问题，谨防这种情况
         void begin(){ cout <<"begin" ;}
      };
    ```
   7. **智能指针**：
      下面有专讲！
   8. **右值引用**：
      可以取地址的就是左值，不可以取地址的就是右值。
      可以使临时对象的拷贝具有move语义，从而可以使临时对象的拷贝具有浅拷贝的效率，可以一定程度上解决临时对象得到深拷贝所带来的效率折损问题。
      右值引用一般代表一些将亡值，也就是马上要被销毁的值，例如按值返回的临时对象，运算表达式产生的临时对象，字面值，lambda表达式等。
      std::move();

2. [内存四区：栈区、堆区、数据区、代码区](https://blog.csdn.net/zxcvbnm0014/article/details/43407927)
   1. 栈区：由编译器自动分配释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈；
   2. 堆区：一般由程序员分配释放，若程序员不释放，程序结束时可由系统回收；
   3. 数据区：包括静态全局区和常量区。静态全局区：全局变量和静态变量的存储在该位置，程序结束后由系统释放。常量区：常量字符串放置的位置；
   4. 代码区：存放函数体的二进制代码。

3. [堆和栈的区别](https://www.cnblogs.com/xiaocai0923/p/10223188.html)
   

4. [STL 底层数据结构的实现](https://www.cnblogs.com/hustlijian/p/3611424.html)
   1. vector 底层实现为数组，支持快速随机访问;
   2. list 底层实现为双向链表，支持快速增删;
   3. deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾快速增删，也支持随机访问;deque是一个双端队列(double-end queue),也是在堆中保存内容的，
   [堆1]->[堆2]->...，堆之间有指针指向，像是 list和vector的结合品。
   1. stack 底层一般用list或deque实现，封闭头部即可。不用vector的原因是容量大小有限制，扩容耗时；
   2. queue 底层一般用list或者deque实现；
   3. stack和queue其实是适配器，而不叫容器，因为是对容器的封装；
   4. priority_queue 底层数据结构一般以vector为底层容器，堆heap为处理规则来管理底层容器实现；
   5. set、 map 底层数据结构为红黑树，有序，不重复
   6. multiset 、 multimap 底层数据结构为红黑树，有序，可重复
   7.  unordered_map、unordered_set 底层数据结构为hash表(哈希桶)，无序，不可重复

5. [虚函数的底层实现](https://blog.csdn.net/u011000290/article/details/50498683)
   C++中的多态是通过虚函数来实现的。虚函数底层通过虚函数表实现。每个有virtual关键字的类都会创建一个虚函数表，表中存储指向虚函数地址的指针。在实例化一个带有虚函数表的类的实例时，都会隐式创建一个虚函数指针指向对应的虚函数表。

6. [多态、虚函数表](https://blog.csdn.net/derkampf/article/details/62046205)
   1. 静态多态：一个函数的多种状态，通过重载实现，在编译阶段即可知道实际调用的函数；
   2. 动态多态：使用虚函数来实现。通过使用父类型别的 指针指向其子类的实例，然后通过父类的指针调用时机子类的成员函数，从而可以让父类的指针有"多种形态"，也是C++的一种泛型技术。
   3. 虚函数表：编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量），和内存的字节对齐有关。
   
7. [泛型](https://www.cnblogs.com/wangduo/p/5559260.html)
   试图使用不变的代码来实现可变的算法。
   要么试图做到在编译时决议，要么试图做到运行时决议。
   1. 模板技术：模板函数与模板类
   2. 虚函数技术
   3. [RTTI技术](https://www.cnblogs.com/xuelisheng/p/9479288.html)：Runtime Type Information，运行时类型信息

8. [析构函数与虚函数](https://blog.csdn.net/weicao1990/article/details/81911341)
   虚析构函数是为了避免内存泄漏，而且是当子类中会有指针成变量时才会用到的。这样做是为了当用一个基类的指针删除一派生类的对象时，派生类的析构函数会被调用。虚析构函数使在删除指向子类对象的基类指针时可以调用子类的析构函数达释放子类中堆内存的目的，从而防止内存泄漏。
   ```cpp
   Animal* animal = new Dog();   // 基类的指针指向派生类
   animal->eat();
   delete animal;                // 使用指向派生类的基类指针删除派生类的堆空间
   ```

9.  [构造函数能否是虚函数](https://www.cnblogs.com/lixiaohui-ambition/archive/2012/08/28/2660708.html)
   构造函数不可以为虚函数。


10. [含有虚函数的类的 sizeof 的大小](https://www.cnblogs.com/younes/archive/2010/06/07/1753488.html)
   1. 一个类中若有虚函数，那么类中就会有一个隐式的成员变量:虚函数指针，这个指针指向一个虚函数表。
   2. 假设所有的成员对齐之后的类的大小为 size 字节 ， 那么类的sizeof的大小为 size + 4*(虚函数指针的个数)。虚函数指针的个数为派生类继承的带有虚函数父类的个数。
   3. 带有虚函数的类的 sizeof 的大小和虚函数的个数不相关，相关的是虚函数的指针个数。
   
11. [struct字节对齐规则](https://www.cnblogs.com/yichi/p/9478004.html)
   1. #pragma pack(N) 编译器用 'N' 来设置数据的对齐方式。默认32位的OS对齐字节是4 ， 64位的对齐字节是8。 'N' 有可能会影响结构体内部成员的对齐位置，以及结构体整体大小。
   2. 每个成员变量在其结构体内部的偏移量都是“MIN(对齐字节，成员变量类型的大小)”的倍数；
   3. 如果有嵌套结构体，那么内嵌结构体的第一个成员变量在外结构体中的偏移量，是"MIN(对齐字节，内嵌结构体中数据类类型大小最大的成员变量)"的倍数。
   4. 整体结构体的大小要是“MIN(对齐字节，这个结构体内数据类型大小最大的成员变量)”的倍数。如果有内嵌结构体，那么取“MIN(对齐字节，内嵌结构体中数据类型大小最大的成员变量)”作为计算外结构体整体大小的依据。

12. [指针和引用的区别](https://www.cnblogs.com/yuanqiangfei/p/11248160.html)
   1. 指针是实体，引用是别名，没有空间。
   2. 引用定义时必须初始化，指针不用。
   3. 指针可以改，引用不可以。
   4. 引用不能为空，指针可以。
   5. sizeof(引用)计算的是它引用的对象的大小，而sizeof(指针)计算的是指针本身的大小。
   6. 不能有NULL引用，引用必须与一块合法的存储单元关联。
   7. 给引用赋值修改的是该引用与对象所关联的值，而不是与引用关联的对象。
   8. 如果返回的是动态分配的内存或对象，必须使用指针，使用引用会产生内存泄漏。
   9. 对引用的操作即是对变量本身的操作。
   10. 删除引用不需要释放内存，其不是对象的副本；删除指针需要释放内存。

13. [static 关键字 、静态变量、静态方法](https://www.cnblogs.com/swisszhang/p/9892992.html)
    1. 静态资源属于类，但是是独立于类存在的;
    2. 静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的; 所以对于静态资源来说，它是不可能知道一个类中有哪些非静态资源的；但是对于非静态资源来说就不一样了，由于它是new出来之后产生的，因此属于类的这些东西它都能认识。
       1. 静态方法能不能引用非静态资源？不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。
       2. 静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。
       3. 非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。
   
14. [const与define的比较](https://blog.csdn.net/qq_41804181/article/details/82714026)
    1.  编译器处理时间不一样： define是宏命令，预处理阶段进行替换， const在编译阶段；
    2.  类型和安全检查不同：define只做展开，不进行类型检查。const常量有具体的类型，在编译阶段会执行类型检查；
    3.  const可以节省空间，避免不必要的内存分配。const定义的常量在程序运行过程中只有一份拷贝，在全局静态区，define定义的常量在内存中有若干个拷贝；
    4.  编译器通常不为普通的const常量分配存储空间，而是将他们保存在符号表中，这使它成为一个编译期间的常量，没有了存储于读内存的操作，使得它的效率也很高。
15. [顶层const、底层const](https://blog.csdn.net/qq_19528953/article/details/50922303)
    针对指针，分为顶层和底层。
    1.  顶层 const ,表示指针本身是个常量，不能改变所**指向地址**的指针 ， int* const p;
    2.  底层 const ,表示指针所指的对象是一个常量,不能改变其所**指向内容**的指针， int const *p;
   作用: 
      1. 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const.
      2. 使用命名的强制类型转换函数const_cast时，需要区分底层cosnt以及顶层cosnt，因为const_cast只能改变运算对象的底层const.


16. [C++ 4种类型转换](http://blog.sina.cn/dpool/blog/s/blog_94a1fe540102yoaj.html)
    1.  static_cast: 任何具有明确定义的类型转换，只要不包含底层const， 都可以使用 static_cast。在编译期强制转换。
    2.  const_cast: 只能改变运算对象的底层const,用来移除变量的const或volatile限定符。
    1.  dynamic_cast：转换的目标必须是类的指针、类的引用或者void*，用于将基类的指针或引用安全地转换成派生类的指针或引用。不能用于内置的基本数据类型的强制转换。在运行期强制缓缓，运行时需要进行类型的检查，较安全。
    2.  reinterpret_cast： 在指针之间转换，将一个类型的指针转换成另一个类型的指针，无关类型。它会缠身一个新的值，这个值会与原始参数有完全相同的比特位。

17. [C++ new、malloc](https://www.cnblogs.com/avril/p/3175175.html)
    [内存分配结果](https://blog.csdn.net/nie19940803/article/details/76358673)
    1.  new / malloc成功与失败：在使用malloc分配内存时，一定要检查返回值是否为"空指针"即可判断是否分配内存成功。而new一个对象时，失败时会抛出异常，所以如果检查new一个对象是否成功，应该捕捉异常。
    ```cpp
      try{
         int* p = new int[];
      } catch(const bad_alloc& e){
         cerr << "bad new int..." << endl;
      }
    ```
    c++里也提供了一个方法来抑制new抛出异常，而返回空指针，这样也可以用是否为空指针来进行判断。
    ```cpp
      int* p = new (std::nothrow)int;
      if(p == NULL)
         return -1;
    ```
    2.  new 、delete是关键字，需要编译器进行支持 ， malloc/free是库函数，需要头文件支持。
    3.  new无需指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显示地指出所需内存的尺寸。
    4.  new内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，是安全性的操作符。malloc内存分配成功则是返回void*，需要通过强制类型转换。
    5.  new 首先调用operate new函数，申请足够多的内存(底层是通过调用 malloc函数实现)，然后在调用类型得到构造函数，初始化成员变量，最后返回自定义类型指针。 malloc是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
    6.  new操作符从自由存储区(free store)上为对对象动态分配内存空间，malloc从堆上动态分配内存。

18. [进程的地址空间内存分配](https://blog.csdn.net/cl_linux/article/details/80328608)
   程序段
   初始化过的数据(Data)
   未初始化过的数据(BSS)
   栈
   堆
19. [深拷贝与浅拷贝](https://blog.csdn.net/weixin_41143631/article/details/81486817)
    会调用拷贝构造函数的场景：
         1. 一个对象以值传递的方式传入函数体；
         2. 一个对象以值传递的方式从函数返回；
         3. 一个对象需要通过另一个对象进行初始化。
    1. 浅拷贝：缺省的拷贝构造函数对于基本类型的成员变量，按字节进行复制，对于类类型的成员变量，调用其相关类型的拷贝构造函数。多个对象公用同一块资源，同一块资源释放多次，造成崩溃或者内存泄漏。当 a 指向 b 执行浅拷贝时，b的改变会影响 a 的改变，同时a原本指向的空间发生过内存泄漏。
    2. 深拷贝：每个对象拥有自己的资源，必须显示提供拷贝构造函数和赋值运算符。

20. [静态函数不能定义为虚函数与常函数](https://www.cnblogs.com/lakeone/p/5967548.html)
